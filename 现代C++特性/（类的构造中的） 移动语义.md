C++11中引入了右值引用，这是移动语义所必须的。

在C++编程中，很多时候我们并不希望将一个对象从一处复制到另一处，但很多情况下我们别无选择只能复制。

例如，在获得函数返回值时，我们实际上是复制了那个函数所返回的对象。

同时，在向函数传入参数时，函数也必须获得这个对象的所有权，即必须复制。而在复制过程中，我们必须==在内存中里临时构造一个对象并拷贝它==，这会产生开销。

如果我们移动一个对象而不是拷贝一个对象（尤其是像字符串这样的大对象），就能极大节约性能开销，因为==这个一次性对象其实只服务于这次参数传入。==

移动构造函数的常见写法：
```
String(String&& other) noexcept
{
m_Size = other.m_Size;
m_Data = other.m_Data; //浅拷贝

other.m_Size = 0; 
other.m_Data = nullptr; //置空传入的右值
}
```

这相当于一个简化版的 std::move 实现。

**下面是一个例子。**

假设String类型是一个有构造，移动，拷贝函数的类。这时的构造共四种情况，即构造函数中的形参是值类型或引用类型，以及传入的变量是左值还是右值。
第一种情况，构造函数中的形参是**值类型**,即：
```
Entity(String name) 
	: m_Name(std::move(name))
{}
```
且传入的变量是**左值**，即：
```
String s("mcaswen");
Entity(s);
```
那么这个过程中：
第一步是`String s("mcaswen");`，这会调用一次普通构造函数。
第二步是其实是`String name = s;`而由于传入的是左值，所以只能触发拷贝构造函数，这是一次拷贝。
第三步是`String m_Name = std::move(name);`这里name是左值，但是因为使用了 std::move ，所以 name 数据的所有权被移动构造函数转移至了 m_Name 中，这是一次移动。

总：一次构造 + 一次拷贝 + 一次移动

第二种情况，形参类型不变，但传入的变量是**右值**，即：
```
Entity(String("mcaswen"));
```
那么这个过程中：
第一步是`String("mcaswen");`，这会调用一次普通构造函数。
第二步是其实是`String name = String("mcaswen");`而由于这回等式右边的String("mcaswen")是右值，==编译器会优先选择移动构造函数​==，所以可以触发移动构造函数，这是一次移动。
第三步是`String m_Name = std::move(name);`与第一种情况同理，这是一次移动。

总：一次构造 + 两次移动

第三种情况，构造函数中的形参是**引用类型**,即：
```
Entity(const String& name) 
	: m_Name(name)
{}
```
且传入的变量是**左值**，即：
```
String s("mcaswen");
Entity(s);
```
那么这个过程中：
第一步是`String s("mcaswen");`，这会调用一次普通构造函数。
第二步是其实是`const String& name = s;`这里name引用自s，不会触发移动或拷贝。
第三步是`String m_Name = name;`这里name是引用自s的左值，无法触发移动（若使用 std::move 会产生原左值s置空问题，与预期不符），于是触发拷贝构造函数，这是一次拷贝。

总：一次构造 + 一次拷贝。

第四种情况，形参类型不变，但传入的变量是**右值**，即：
```
Entity(String("mcaswen"));
```
那么这个过程中：
第一步是`const String& nameString("mcaswen");` 这里是将右值传入const类型左值引用，name引用自一个临时变量，不会触发移动或拷贝。
第二步是`String m_Name = name;`与第三种情况同理，这是一次拷贝（这里可以使用std::move()，但会让第三种情况中的左值传入产生置空问题，下方讨论右值引用重载情况）。

\**第五种情况，右值引用重载：*
```
Entity(String&& name) : 
	m_Name(std::move(name)) 
{}
```
那么这个过程中：
第一步是`String&& name = String("mcaswen");` 这里是将右值传入右值引用，name引用自一个临时变量，不会触发移动或拷贝。
第二步是`String m_Name = std::move(name);`与第一种情况同理，这是一次移动。

总：一次构造 + 一次移动。

由此可见，若一个对象内存占用较大，性能开销大约是*第五种* < 第二种 < 第三种 = 第四种 < 第一种。

这就是为什么现代C++推荐我们使用按值传递 + 移动语义 + 右值引用重载方法初始化参数，因为其性能开销最小。

**小结：**
现代C++中，移动语义的加入使我们得以将以前看似不可避免的值拷贝优化为移动，这是程序运行性能提升的关键之一。而通过对左值/右值传入，引用/值类型形参等五种情况的讨论，我们也发现以往“引用至上”的金科玉律似乎也被打破----毕竟一次对巨无霸数据的拷贝开销可能大于成百上千次移动。总之，多进行拷贝 vs 移动的思考，将移动语义列入我们编写高性能程序的强大工具列表中，是现代C++的一大重要原则。
